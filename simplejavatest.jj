options {
  IGNORE_CASE=false;
}

PARSER_BEGIN(simplejava)

public class simplejava {
}

PARSER_END(simplejava)

TOKEN_MGR_DECLS :
{
    public static int numComments = 0;
}

SKIP :
{
    <" ">
|   <"\n">
|   <"\t">
|   < "//" (~["\n"])* "\n">
|   <"/*">     {numComments++; SwitchTo(IN_COMMENT);}
}

<IN_COMMENT>
SKIP :
{
    < "/*"> {numComments++;}
|   < "*/">     {
        numComments -= 1;
        if(numComments == 0){
            SwitchTo(DEFAULT);
        }
    }
|   < ~[]>
}

TOKEN :
{
    < FOR: "for">
|   < IF: "if">
|   < WHILE: "while">
|   < DO: "do">
|   < ELSE: "else">
|   < CLASS: "class">
|   < TRUE: "true">
|   < FALSE: "false">
|   < RETURN: "return">
}

TOKEN :
{
    < INTEGER_LITERAL: (("-" | {})["0"-"9"])+>
|   < IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

TOKEN :
{
    < PLUS: "+">
|   < MINUS: "-">
|   < MULTIPLY: "*">
|   < DIVIDE: "/">
|   < EQUAL: "==">
|   < GT: ">">
|   < NOT: "!">
|   < LEFT_BRACE: "{">
|   < LEFT_BRACKET: "[">
|   < RIGHT_BRACKET: "]">
|   < PERIOD: ".">
|   < COMMA: ",">
|   < GT_EQ: ">=">
|   < SEMICOLON: ";">
|   < AND: "&&">
|   < RIGHT_BRACE: "}">
|   < LEFT_PARENTHESIS: "(">
|   < RIGHT_PARENTHESIS: ")">
|   < NOT_EQUAL: "!=">
|   < LT_EQ: "<=">
|   < LT: "<">
|   < GETS: "=">
|   < OR: "||">
}

void program():
{}
{
    (mainfunc())+
}

void mainfunc():
{}
{
    ("void main") <LEFT_PARENTHESIS> <RIGHT_PARENTHESIS> <LEFT_BRACE>

    block()
}

void block():
{}
{
    (statement())* <RIGHT_BRACE>
}

void statement():
{}
{
    LHS()
}

void LHS():
{}
{
    var() LHS_prime()
}

void LHS_prime():
{}
{
    var() LHS_prime()
|   complex() LHS_prime()
|   RHS()
}

void RHS():
{}
{
    <SEMICOLON>
|   <GETS> RHS_prime()
}

void RHS_prime():
{}
{
    var() RHS_prime()
|   <SEMICOLON>
|   complex() RHS_prime()
}

void var():
{}
{
    <INTEGER_LITERAL>
|   <IDENTIFIER>
}

void complex():
{}
{
    <LEFT_BRACKET> complex_prime()
|   <PERIOD> var()
|   <LEFT_PARENTHESIS> complex_prime()
|   <RIGHT_BRACKET>
}

void complex_prime():
{}
{
    var() complex()
|   <RIGHT_BRACKET>
|   <RIGHT_PARENTHESIS>
}

void classdef():
{}
{
    <CLASS> <IDENTIFIER> <LEFT_BRACE> (initialization())* <RIGHT_BRACE>
}

void boolean_expression():
{}
{
    <NOT> expression()
|   expression() boolean_operator() expression()
}

void boolean_operator:
{}
{
    (<OR> | <EQUAL> | <AND> | <NOT_EQUAL> | <GT_EQ> | <LT_EQ> | <LT> | <GT>)
}

void expression():
{}
{
    var() expression_prime()
|   <MINUS> var() expression_prime()
|   LOOKAHEAD(3) <LEFT_PARENTHESIS> <MINUS> var() expression_prime()
|   <LEFT_PARENTHESIS> expression()
}

void expression_prime():
{}
{
    LOOKAHEAD(2) (<MULTIPLY> | <DIVIDE> | <PLUS> | <MINUS>) var() expression_prime() boolean_operator()
|   (<MULTIPLY> | <DIVIDE> | <PLUS> | <MINUS>) <MINUS> var() expression_prime() boolean_operator()
|   <RIGHT_PARENTHESIS> expression_prime() boolean_operator()
}
